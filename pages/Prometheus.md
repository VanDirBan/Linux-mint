- **Prometheus: Fundamentals of Monitoring**
	- **Definition**:
		- **Prometheus** is an open-source monitoring and alerting toolkit, originally developed at SoundCloud.
		- It provides a multi-dimensional data model, real-time metrics collection, flexible querying, and alerting.
		- Commonly used in environments with **microservices**, [[Kubernetes]] clusters, and #Docker-based workloads.
	- **Why Prometheus?**
		- **Time-Series Database (TSDB)**:
			- Prometheus stores all metrics as time-series data, identified by metric names and key-value pairs (labels).
			- This structure facilitates detailed and flexible querying of metrics over time.
		- **Pull-Based Model**:
			- Prometheus scrapes (pulls) metrics from targets (e.g., application endpoints, exporters).
			- Simplifies architecture in dynamic environments like [[Kubernetes]], where endpoints may frequently change.
		- **Highly Scalable**:
			- Designed for cloud-native scaling.
			- Can handle large volumes of metrics, especially when sharded or federated across multiple Prometheus servers.
		- **Powerful Query Language (PromQL)**:
			- PromQL lets you filter, aggregate, and evaluate time-series data in real-time.
			- Enables advanced dashboarding and alerting scenarios.
	- **Core Components**:
		- 1. **Prometheus Server**:
			- Scrapes metrics from configured targets.
			- Stores data locally in a time-series database.
			- Executes alerts based on PromQL expressions.
		- 2. **Exporters**:
			- Collect and expose metrics for various systems (e.g., **Node Exporter** for Linux, CPU/memory stats).
			- Allows monitoring of databases, caches, or even custom applications.
		- 3. **Alertmanager**:
			- Handles alerts generated by the Prometheus server.
			- Routes alerts to different channels (e.g., #Slack, Email, PagerDuty).
			- Supports grouping, silencing, and inhibition rules.
		- 4. **PromQL**:
			- Query language used to select and aggregate time-series data.
			- Example: `sum(rate(http_requests_total[5m]))` aggregates HTTP requests over the last 5 minutes.
		- 5. **Service Discovery**:
			- Integrates with platforms like [[Kubernetes]], #Docker Swarm, AWS, or static configurations.
			- Dynamically updates scrape targets as services come and go.
	- **Metrics Collection Flow**:
		- 1. **Application/Exporter**:
			- An application or exporter exposes metrics via HTTP endpoint (e.g., `:9100/metrics`).
		- 2. **Prometheus Server**:
			- Scrapes these metrics at configured intervals.
		- 3. **Local TSDB**:
			- Metrics are stored in Prometheus’s local time-series database.
		- 4. **PromQL**:
			- Users query stored metrics for dashboards, troubleshooting, or capacity planning.
		- 5. **Alertmanager**:
			- If queries match alerting rules, alerts are routed to on-call systems or #Slack.
	- **Deployment & Integration**:
		- **Stand-Alone Deployment**:
			- Install binaries in a VM or bare-metal environment.
			- Configure `prometheus.yml` for scrape targets.
			- Good for smaller on-prem or single-cloud use cases.
		- **Containerized**:
			- Run in #Docker or #Podman, specifying `prometheus.yml` via a volume.
			- Easy to incorporate into [[Kubernetes]] using Helm charts or operator-based deployment.
		- **High Availability**:
			- Run multiple Prometheus servers with identical scrape configs for redundancy.
			- Use external storage or remote-write solutions for long-term data retention.
		- **Integration with #Grafana**:
			- Grafana is a popular dashboarding tool that can query Prometheus and visualize data in real-time.
			- Typically used together for advanced data visualization.
	- **Use Cases**:
		- **Infrastructure Monitoring**: CPU, memory, disk, network for servers and VMs.
		- **Application Performance Monitoring (APM)**: Request latencies, error rates, concurrency levels.
		- **Microservices**:
			- Each service can expose custom metrics to track performance or business-related KPIs.
		- **[[Kubernetes]]**:
			- Monitor cluster health (nodes, pods, deployments, etc.) using the **kube-state-metrics** and **cAdvisor** exporters.
		- **Alerting**:
			- Automate notifications for critical conditions (e.g., high CPU usage, error spikes).
			- Integrate with #Slack, Email, or PagerDuty to handle on-call escalations.
	- **Basic Configuration Example** (simplified `prometheus.yml`):
	  ```yaml
	  global:
	    scrape_interval: 15s
	    evaluation_interval: 15s
	  
	  scrape_configs:
	    - job_name: 'node_exporter'
	      static_configs:
	        - targets: ['192.168.1.10:9100']
	    - job_name: 'my_app'
	      static_configs:
	        - targets: ['192.168.1.20:8080']
	  ```
		- **`scrape_interval`**: Frequency of scraping targets.
		- **`evaluation_interval`**: Frequency of evaluating alert rules.
		- **`scrape_configs`**: Lists each scrape target (job).
	- **Tips & Best Practices**:
		- **Use Labels Wisely**: Metrics are key-value pairs—avoid label bloat that can cause performance issues.
		- **Alert Tuning**: Set realistic thresholds to avoid alert fatigue. Group or route alerts meaningfully in Alertmanager.
		- **Record Rules**: Precompute frequently queried metrics to reduce PromQL load at query time.
		- **Retention & Storage**:
			- By default, Prometheus stores data locally, which might not be suitable for long-term retention.
			- Consider a remote storage adapter or solutions like Thanos, Cortex, or Mimir for extended historical data.
		- **Security**:
			- Enable TLS or a reverse proxy for the Prometheus and exporters endpoints if publicly exposed.
			- Restrict write/administrative access carefully to prevent malicious metric injection.
	- **Conclusion**:
		- **Prometheus** is a cornerstone for modern observability, especially in containerized or microservice environments like [[Kubernetes]].
		- The pull-based metrics collection, combined with PromQL and integrated alerting, provides a flexible monitoring solution.
		- By pairing Prometheus with tools like #Grafana for visualization and best practices around labeling and alert management, you can build a robust, scalable monitoring ecosystem.